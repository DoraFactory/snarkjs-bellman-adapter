# snarkjs-bellman-adapter
The adapter for snarkjs(generate proof) and bellman(verify the proof)

## Background
At present, ZK has developed rapidly with the rise of blockchain, and many proof systems have emerged, such as `Groth16`, `Plonk`, `Halo` and so on. 
ZK application needs two requrements, one is the writing of the circuit, one is the application of the proof system.
There are many excellent ZK development tools libraries, such as `Circom` (a DSL for circuit writing), `SnarkJs` (a Javascript library for generating zk proof and verifying), `Bellman` and `ArkWorks` (ZK Snark library based on Rust).
This tutorial was developed to meet the requirements for Verifying the zk proof based on Rust's back-end services.
We know that circom is very convenient to write circuits, and usually after the circuits are written, we can easily generate the corresponding proof by SnarkJs for verification. However, when we use Rust for application development, we did not find a suitable Rust library to match the proof produced by SnarkJs, so we developed this adapter to decode the data generated by the snarkjs to satisfy the requirement of Bellman.

So, we can use this adapter to get below benefits:
- use `circom` to write circiuit and compile into R1CS easily(circom is an excellent DSL to write circuit, which is similar to the programming paradigms of high-level languages, instead of Bellman or arkworks. So, we can aviod many latent errors).
- use `snarkjs` to generate zk proof(when we develop a zk application, especially a web app, we may use javascript in the frontend.There is no doubt that snarkjs js a best choice).
- use `bellman` to verify the proof generated by the snarkjs(when we need to verify the proof in the backend using the Rust, whether it is blockchain or other services, we need a rust library to verify the snarkjs's proof. we did not find a Rust library can do it. bellman is an advanced ZK library developed by the Zcash. It also has experienced the practice of production environment, so we choose it to be the rust library).

## prerequirement
> we know snarkjs support `bn128` and `bls12_381` curve. Bellman support only `bls12_381` curve. So we choose `bls12_381` curve. So, `if you developed the zk application by bn128 curve in the past, you only need to change the curve to bls12_381`.

Complete the [tutorial](https://github.com/iden3/snarkjs/blob/master/README.md) of snarkjs.(This tutorial operates in bn128)

**Attention: recommend to install circom by the latest source code and compile it into the executable file `circom`**.
```
git clone https://github.com/iden3/circom.git
cargo build --release
```

## Using of this adapter
### 1. Generate zk proof of BLS12_381 curve
Following the [tutorial](https://github.com/iden3/snarkjs/blob/master/README.md) of sanrkjs, we need to modify some steps to generate the proof of `bls12_381`

- step1: 
```
snarkjs powersoftau new bls12_381 12 pot12_0000.ptau -v
```
- step4:
```
snarkjs powersoftau challenge contribute bls12_381 challenge_0003 response_0003 -e="some random text"
```
- step10
```
circom circuit.circom --r1cs --wasm --sym -p bls12381
```
- step18
```
snarkjs zkey bellman contribute bls12_381 challenge_phase2_0003 response_phase2_0003 -e="some random text"
```

If you modify the above d in snakjs's tutorial, you can generate a proof of bls_381 curve.

### 2. Decode the proof into uncompressed data
You have generated `proof.json` and `verification_key.json`ï¼Œyou can go to the directory `prove` and run these command:
```
npm install
node adapter.js
```
After that, you can see the generated uncompressed data file `proof_uncompressed.json` and `vkey_uncompressed.json`.

### 3. Encode the uncompressed data into Affine and Verify
Go to the directory `verify/src/adapter` and run the test:
```
cargo test snark_proof_bellman_verify -- --nocapture
```
if you see the below output, which means the verification passed.

```
running 1 test
>>>>start encode the uncompressed data to Affine<<<<<
>>>>end verification<<<<<<<
test adapter::snark_proof_bellman_verify ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.07s
```
